name: Release Pipeline

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'The package name to release (e.g., xrpl, ripple-address-codec)'
        required: true
      release_branch:
        description: 'Release branch the release is generated from'
        required: true
      npmjs_dist_tag:
        description: 'npm distribution tag(Read more https://docs.npmjs.com/adding-dist-tags-to-packages)'
        default: ''
        required: true

concurrency:
  group: release
  cancel-in-progress: true

jobs:
  get_version:
    runs-on: ubuntu-latest
    name: Get release version from package.json
    outputs:
      package_version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          fetch-depth: 0

      - name: Validate inputs
        run: |
          set -euo pipefail
          if git ls-remote --exit-code origin "refs/heads/${{ github.event.inputs.release_branch }}" > /dev/null; then
            echo "‚úÖ Found release branch: ${{ github.event.inputs.release_branch }}"
          else
            echo "‚ùå Release branch ${{ github.event.inputs.release_branch }} not found in remote. Failing workflow."
            exit 1
          fi

          if grep -R --exclude-dir=.git --exclude-dir=.github "artifactory.ops.ripple.com" .; then
            echo "‚ùå Internal Artifactory URL found"
            exit 1
          else
            echo "‚úÖ No Internal Artifactory URL found"
          fi

      - name: Get package version from package.json
        id: get_version
        run: |
          set -euo pipefail
          PACKAGE_NAME="${{ github.event.inputs.package_name }}"
          PKG_JSON="packages/${PACKAGE_NAME}/package.json"
          if [[ ! -f "$PKG_JSON" ]]; then
            echo "package.json not found at $PKG_JSON. Check 'package_name' input." >&2
            exit 1
          fi
          VERSION=$(jq -er .version "$PKG_JSON")
          if [[ -z "$VERSION" || "$VERSION" == "null" ]]; then
            echo "Version is empty or missing in $PKG_JSON" >&2
            exit 1
          fi
          echo "PACKAGE_VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

  run_faucet_test:
    name: Run faucet tests ${{ needs.get_version.outputs.package_version }}
    needs: [get_version]
    uses: ./.github/workflows/faucet_test.yml
    with:
      git_ref: ${{ github.event.inputs.release_branch }}
    secrets: inherit

  run_tests:
    name: Run unit/integration tests ${{ needs.get_version.outputs.package_version }}
    permissions:
      contents: read
      id-token: write
      pages: write
    needs: [get_version]
    uses: ./.github/workflows/nodejs.yml
    with:
      git_ref: ${{ github.event.inputs.release_branch }}
    secrets: inherit

  pre_release:
    runs-on: ubuntu-latest
    needs: [get_version, run_faucet_test, run_tests]
    name: Pre Release Pipeline for ${{ needs.get_version.outputs.package_version }}
    permissions:
      issues: write
    env:
      PACKAGE_VERSION: "${{ needs.get_version.outputs.package_version }}"
      PACKAGE_NAME: "${{ github.event.inputs.package_name }}"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: 'https://registry.npmjs.org'

      - name: Build package
        run: |
          # dubugging info
          npm --version
          node --version
          ls -l
          pwd

          #build
          npm ci
          npm run build

      - name: Notify Slack if tests fail
        if: failure()
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
        run: |
          MESSAGE="‚ùå Build failed for xrpl.js ${{ env.PACKAGE_VERSION }}. Check the logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          curl -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
                  --arg channel "#test-alert" \
                  --arg text "$MESSAGE" \
                  '{channel: $channel, text: $text}')"

      - name: Install cyclonedx-npm
        run: npm install -g @cyclonedx/cyclonedx-npm

      - name: Generate CycloneDX SBOM
        run: cyclonedx-npm --output-format json --output-file sbom.json

      - name: Scan SBOM for vulnerabilities using Trivy
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: sbom
          scan-ref: sbom.json
          format: table
          exit-code: 0
          output: vuln-report.txt
          severity: CRITICAL,HIGH

      - name: Upload sbom to OWASP
        run: |
          curl -X POST \
            -H "X-Api-Key: ${{ secrets.OWASP_TOKEN }}" \
            -F "project=7c40c8ea-ea0f-4a5f-9b9f-368e53232397" \
            -F "bom=@sbom.json" \
            https://owasp-dt-api.prod.ripplex.io/api/v1/bom

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json

      - name: Print scan report
        run: cat vuln-report.txt

      - name: Upload vulnerability report artifact
        id: upload_vuln
        uses: actions/upload-artifact@v4
        with:
          name: vulnerability-report
          path: vuln-report.txt

      - name: Build vuln artifact URL
        id: vuln_art
        run: |
          echo "art_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/${{ steps.upload_vuln.outputs.artifact-id }}" >> "$GITHUB_OUTPUT"

      - name: Create issue if CRITICAL/HIGH found
        uses: ./.github/actions/create-github-issue
        with:
          vuln_art_url: ${{ steps.vuln_art.outputs.url }}
          report_path: vuln-report.txt
          package_name: ${{ env.PACKAGE_NAME }}
          package_version: ${{ env.PACKAGE_VERSION }}
          release_branch: ${{ github.event.inputs.release_branch }}
          labels: "security"

      - name: Generate lerna.json for choosen the package
        run: |
          echo "üîß Updating lerna.json to include only packages/${{ env.PACKAGE_NAME }}"
          # Use jq to update the packages field safely
          jq --arg pkg "packages/${{ env.PACKAGE_NAME }}" '.packages = [$pkg]' lerna.json > lerna.tmp.json && mv lerna.tmp.json lerna.json
          echo "‚úÖ lerna.json updated:"
          cat lerna.json

      - name: Pack tarball
        run: |
          set -euo pipefail
          echo "Packaging ${{ env.PACKAGE_NAME }}"
          find "packages/${{ env.PACKAGE_NAME }}" -maxdepth 1 -name '*.tgz' -delete || true
          TARBALL=$(npx lerna exec --scope "@shichengsh001/${{ env.PACKAGE_NAME }}" -- npm pack --json | jq -r '.[0].filename')
          echo "TARBALL=packages/${{ env.PACKAGE_NAME }}/${TARBALL}" >> "$GITHUB_ENV"

      - name: Upload tarball as artifact
        uses: actions/upload-artifact@v4
        with:
          name: npm-package-tarball
          path: ${{ env.TARBALL }}

  review:
    runs-on: ubuntu-latest
    needs: [get_version, run_faucet_test, run_tests, pre_release]
    name: Review test and security scan result
    env:
      PACKAGE_VERSION: "${{ needs.get_version.outputs.package_version }}"
      PACKAGE_NAME: "${{ github.event.inputs.package_name }}"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          fetch-depth: 0
      - name: Create PR from release branch to main (skips for rc/beta)
        if: |
          !contains(needs.get_version.outputs.package_version, '-rc') &&
          !contains(needs.get_version.outputs.package_version, '-beta')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RELEASE_BRANCH: ${{ github.event.inputs.release_branch }}
          VERSION: ${{ needs.get_version.outputs.package_version }}
        run: |
          set -euo pipefail
          echo "üîé Checking if a PR already exists for $RELEASE_BRANCH ‚Üí main‚Ä¶"
          PR_NUMBER="$(gh pr list --repo "$REPO" --base main --head "$RELEASE_BRANCH" --state open --json number --jq '.[0].number' || true)"
          if [ -n "${PR_NUMBER:-}" ]; then
            echo "‚ÑπÔ∏è PR already exists: #$PR_NUMBER"
            PR_URL="https://github.com/$REPO/pull/$PR_NUMBER"
          else
            echo "üìù Creating PR for release $VERSION from $RELEASE_BRANCH ‚Üí main"
            PR_URL="$(gh pr create \
              --repo "$REPO" \
              --base main \
              --head "$RELEASE_BRANCH" \
              --title "Release $VERSION: $RELEASE_BRANCH ‚Üí main" \
              --body "Automated PR for release **$VERSION** from **$RELEASE_BRANCH** ‚Üí **main**. Workflow Run: https://github.com/$REPO/actions/runs/${{ github.run_id }}" \
              --label release \
              --json url --jq .url)"
          fi
          echo "PR_URL=$PR_URL" >> "$GITHUB_ENV"

      - name: Release summary for review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          ENV_NAME: official-release
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
          PACKAGE_VERSION: ${{ env.PACKAGE_VERSION }}
          NPMJS_DIST_TAG: ${{ github.event.inputs.npmjs_dist_tag }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TRIGGERING_ACTOR: ${{ github.triggering_actor }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

        run: |
          set -euo pipefail
          ARTIFACT_NAME="vulnerability-report"
          RELEASE_BRANCH="${{ github.event.inputs.release_branch }}"
          COMMIT_SHA="$(git rev-parse --short HEAD)"

          echo "Fetching artifact ID for ${ARTIFACT_NAME}..."
          ARTIFACTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/artifacts")

          ARTIFACT_ID=$(echo "$ARTIFACTS" | jq -r ".artifacts[] | select(.name == \"$ARTIFACT_NAME\") | .id")

          if [ -z "${ARTIFACT_ID:-}" ]; then
            echo "‚ùå Artifact not found."
            exit 1
          fi

          echo "üîç Please review the following details before proceeding:"
          echo "üì¶ Package Name:   $PACKAGE_NAME"
          echo "üîñ Package Version: $PACKAGE_VERSION"
          echo "üåø Release Branch:  $RELEASE_BRANCH"
          echo "üî¢ Commit SHA:      $COMMIT_SHA"
          echo "üîó Vulnerabilities: https://github.com/$REPO/actions/runs/$RUN_ID/artifacts/$ARTIFACT_ID"

          # executor = the person who triggered the pipeline
          EXECUTOR="${GITHUB_TRIGGERING_ACTOR:-$GITHUB_ACTOR}"

          # Fetch environment and extract required reviewers
          ENV_JSON="$(curl -sSf \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/environments/$ENV_NAME")"

          REVIEWERS="$(printf '%s' "$ENV_JSON" | jq -r '
            (.protection_rules // [])
            | map(select(.type=="required_reviewers") | .reviewers // [])
            | add // []
            | map(
                if .type=="User" then (.reviewer.login)
                elif .type=="Team" then (.reviewer.slug)
                else (.reviewer.login // .reviewer.slug // "unknown")
                end
              )
            | unique
            | join(", ")
          ')"

          if [ -z "$REVIEWERS" ] || [ "$REVIEWERS" = "null" ]; then
            REVIEWERS="(no required reviewers configured)"
          fi

          # RC detection: skip step 2 if RC (dist-tag starts with rc OR version contains -rc)
          IS_RC="false"
          [[ "${NPMJS_DIST_TAG:-}" =~ ^rc ]] || [[ "${PACKAGE_VERSION:-}" =~ -rc ]] && IS_RC="true"

          # Build Step 2 line with PR URL (if available), unless RC
          if [ "$IS_RC" = "true" ]; then
            STEP2_LINE="2. Review the package update PR ‚Äì **SKIPPED for release candidates**."
          else
            if [ -n "${PR_URL:-}" ]; then
              STEP2_LINE="2. Review the package update PR and provide two approvals. DO NOT MERGE - ${EXECUTOR} will verify the package on npm registry and merge this approved PR. (${PR_URL})"
            else
              STEP2_LINE="2. Review the package update PR and provide two approvals. DO NOT MERGE - ${EXECUTOR} will verify the package on npm registry and merge this approved PR."
            fi
          fi

          # Compose message robustly
          printf -v MESSAGE '%s is releasing %s@%s. Two approvers from %s need to take following actions:\n1. Review the release artifacts and approve/reject the release. (%s)\n%s' \
            "$EXECUTOR" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$REVIEWERS" "$RUN_URL" "$STEP2_LINE"

          echo "$MESSAGE"

          # Post to Slack (channel can be changed as needed)
          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "$(jq -n \
                  --arg channel "#test-alert" \
                  --arg text "$MESSAGE" \
                  '{channel: $channel, text: $text}')"

  release:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    needs: [get_version, run_faucet_test, run_tests, pre_release, review]
    name: Release Pipeline for ${{ needs.get_version.outputs.package_version }}
    env:
      PACKAGE_VERSION: "${{ needs.get_version.outputs.package_version }}"
      PACKAGE_NAME: "${{ github.event.inputs.package_name }}"
    environment:
      name: official-release
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.release_branch }}
          fetch-depth: 0

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: npm-package-tarball
          path: dist

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: 'https://registry.npmjs.org/'

      - name: Publish to npm
        run: |
          cd dist
          PKG=$(ls *.tgz)
          echo $PKG
          NPM_DIST_TAG="${{ github.event.inputs.npmjs_dist_tag }}"
          if [ -z "$TAG" ]; then
            TAG="latest"
          fi
          npm install -g npm@latest
          npm publish "$PKG" --provenance --access public --registry=https://registry.npmjs.org/ --tag "$NPM_DIST_TAG"

      - name: Ensure Git tag exists
        id: create_tag
        run: |
          set -euo pipefail
          TAG="${{ env.PACKAGE_NAME }}@${{ env.PACKAGE_VERSION }}"

          git fetch --tags origin

          if git rev-parse "$TAG" >/dev/null 2>&1 ; then
            echo "‚ùå Tag $TAG already exists (not a draft). Failing."
            exit 1
          fi

          echo "üîñ Tagging $TAG"
          git tag -f "$TAG"
          git push origin -f "$TAG"

          echo "tag_name=$TAG" >> "$GITHUB_OUTPUT"

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "${{ steps.create_tag.outputs.tag_name }}"
          name: "${{ steps.create_tag.outputs.tag_name }}"
          draft: false
          generate_release_notes: true
          make_latest: true

      - name: Fetch generated release notes
        id: fetch_notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.gh_release.outputs.id }}      # <- reliable key to fetch by
        run: |
          set -euo pipefail
          resp="$(curl -sSf \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/releases/$RELEASE_ID")"

          body="$(printf '%s' "$resp" | jq -r '.body // ""')"
          url="$(printf '%s' "$resp" | jq -r '.html_url // ""')"

          # Fallback if empty and trim if overly long (Slack safety)
          [ -z "$body" ] || [ "$body" = "null" ] && body="(No release notes were generated.)"
          max=38000
          [ "${#body}" -gt "$max" ] && body="${body:0:$max}\n‚Ä¶(truncated)"

          esc_body="${body//'%'/'%25'}"
          esc_body="${esc_body//$'\n'/'%0A'}"
          esc_body="${esc_body//$'\r'/'%0D'}"
          esc_url="${url//'%'/'%25'}"
          echo "notes=$esc_body" >> "$GITHUB_OUTPUT"
          echo "release_url=$esc_url" >> "$GITHUB_OUTPUT"

      - name: Notify Slack success
        if: success()
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
          TAG: ${{ steps.gh_release.outputs.tag_name }}
          NOTES: ${{ steps.fetch_notes.outputs.notes }}
          RELEASE_URL: ${{ steps.fetch_notes.outputs.release_url }}
        run: |
          set -euo pipefail
          notes="${NOTES//'%0A'/$'\n'}"
          notes="${notes//'%0D'/}"
          text="üì£ New release has been published successfully: ${TAG}\n${RELEASE_URL}\n\n${notes}"
          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "$(jq -n --arg channel "#test-alert" --arg text "$text" '{channel: $channel, text: $text}')"

      - name: Notify Slack if tests fail
        if: failure()
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
        run: |
          MESSAGE="‚ùå Tests failed for xrpl.js ${{ env.PACKAGE_VERSION }}. Check the logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          curl -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
                  --arg channel "#test-alert" \
                  --arg text "$MESSAGE" \
                  '{channel: $channel, text: $text}')"
